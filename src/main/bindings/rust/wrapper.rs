/* automatically generated by rust-bindgen */
use crate::host::descriptor::CompatDescriptor;
use crate::host::descriptor::PosixFile;
use crate::host::descriptor::socket::SocketFile;

pub const CONFIG_PIPE_BUFFER_SIZE: u32 = 65536;
pub const CONFIG_DATAGRAM_MAX_SIZE: u32 = 65507;
pub const SYSCALL_IO_BUFSIZE: u32 = 16384;
pub type size_t = ::std::os::raw::c_ulong;
pub type guint32 = ::std::os::raw::c_uint;
pub type guint64 = ::std::os::raw::c_ulong;
pub type gsize = ::std::os::raw::c_ulong;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __pid_t = ::std::os::raw::c_int;
pub type pid_t = __pid_t;
pub type gchar = ::std::os::raw::c_char;
pub type gint = ::std::os::raw::c_int;
pub type gboolean = gint;
pub type guint = ::std::os::raw::c_uint;
pub type gdouble = f64;
pub type gpointer = *mut ::std::os::raw::c_void;
pub type gconstpointer = *const ::std::os::raw::c_void;
pub type GQuark = guint32;
pub type GList = _GList;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GList {
    pub data: gpointer,
    pub next: *mut GList,
    pub prev: *mut GList,
}
#[test]
fn bindgen_test_layout__GList() {
    assert_eq!(
        ::std::mem::size_of::<_GList>(),
        24usize,
        concat!("Size of: ", stringify!(_GList))
    );
    assert_eq!(
        ::std::mem::align_of::<_GList>(),
        8usize,
        concat!("Alignment of ", stringify!(_GList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GList>())).prev as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_GList),
            "::",
            stringify!(prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GTimer {
    _unused: [u8; 0],
}
pub type GTimer = _GTimer;
pub use self::_LogLevel as LogLevel;
pub const _LogLevel_LOGLEVEL_UNSET: _LogLevel = 0;
pub const _LogLevel_LOGLEVEL_ERROR: _LogLevel = 1;
pub const _LogLevel_LOGLEVEL_CRITICAL: _LogLevel = 2;
pub const _LogLevel_LOGLEVEL_WARNING: _LogLevel = 3;
pub const _LogLevel_LOGLEVEL_MESSAGE: _LogLevel = 4;
pub const _LogLevel_LOGLEVEL_INFO: _LogLevel = 5;
pub const _LogLevel_LOGLEVEL_DEBUG: _LogLevel = 6;
pub const _LogLevel_LOGLEVEL_TRACE: _LogLevel = 7;
pub type _LogLevel = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ShadowLogger {
    _unused: [u8; 0],
}
pub type ShadowLogger = _ShadowLogger;
extern "C" {
    pub fn shadow_logger_getDefault() -> *mut ShadowLogger;
}
extern "C" {
    pub fn shadow_logger_shouldFilter(logger: *mut ShadowLogger, level: LogLevel) -> bool;
}
pub type in_addr_t = u32;
pub type in_port_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Process {
    _unused: [u8; 0],
}
pub type Process = _Process;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Host {
    _unused: [u8; 0],
}
pub type Host = _Host;
#[doc = " Simulation time in nanoseconds. Allows for a consistent representation"]
#[doc = " of time throughput the simulator."]
pub type SimulationTime = guint64;
pub use self::_Status as Status;
pub const _Status_STATUS_NONE: _Status = 0;
pub const _Status_STATUS_DESCRIPTOR_ACTIVE: _Status = 1;
pub const _Status_STATUS_DESCRIPTOR_READABLE: _Status = 2;
pub const _Status_STATUS_DESCRIPTOR_WRITABLE: _Status = 4;
pub const _Status_STATUS_DESCRIPTOR_CLOSED: _Status = 8;
pub const _Status_STATUS_FUTEX_WAKEUP: _Status = 16;
pub type _Status = i32;
pub type LegacyDescriptor = [u64; 6usize];
pub use self::_ProtocolType as ProtocolType;
pub const _ProtocolType_PNONE: _ProtocolType = 0;
pub const _ProtocolType_PLOCAL: _ProtocolType = 1;
pub const _ProtocolType_PTCP: _ProtocolType = 2;
pub const _ProtocolType_PUDP: _ProtocolType = 3;
pub type _ProtocolType = i32;
pub const ProtocolLocalFlags_PLOCAL_NONE: ProtocolLocalFlags = 0;
pub type ProtocolLocalFlags = ::std::os::raw::c_uint;
pub const ProtocolUDPFlags_PUDP_NONE: ProtocolUDPFlags = 0;
pub type ProtocolUDPFlags = ::std::os::raw::c_uint;
pub const ProtocolTCPFlags_PTCP_NONE: ProtocolTCPFlags = 0;
pub const ProtocolTCPFlags_PTCP_RST: ProtocolTCPFlags = 2;
pub const ProtocolTCPFlags_PTCP_SYN: ProtocolTCPFlags = 4;
pub const ProtocolTCPFlags_PTCP_ACK: ProtocolTCPFlags = 8;
pub const ProtocolTCPFlags_PTCP_SACK: ProtocolTCPFlags = 16;
pub const ProtocolTCPFlags_PTCP_FIN: ProtocolTCPFlags = 32;
pub const ProtocolTCPFlags_PTCP_DUPACK: ProtocolTCPFlags = 64;
pub type ProtocolTCPFlags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _StatusListener {
    _unused: [u8; 0],
}
pub type StatusListener = _StatusListener;
extern "C" {
    pub fn statuslistener_ref(listener: *mut StatusListener);
}
extern "C" {
    pub fn statuslistener_unref(listener: *mut StatusListener);
}
extern "C" {
    pub fn statuslistener_onStatusChanged(
        listener: *mut StatusListener,
        currentStatus: Status,
        transitions: Status,
    );
}
pub type SysCallHandler = _SysCallHandler;
pub type PluginVirtualPtr = _PluginVirtualPtr;
pub type PluginPtr = _PluginVirtualPtr;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PluginVirtualPtr {
    pub val: u64,
}
#[test]
fn bindgen_test_layout__PluginVirtualPtr() {
    assert_eq!(
        ::std::mem::size_of::<_PluginVirtualPtr>(),
        8usize,
        concat!("Size of: ", stringify!(_PluginVirtualPtr))
    );
    assert_eq!(
        ::std::mem::align_of::<_PluginVirtualPtr>(),
        8usize,
        concat!("Alignment of ", stringify!(_PluginVirtualPtr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PluginVirtualPtr>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PluginVirtualPtr),
            "::",
            stringify!(val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SysCallReg {
    pub as_i64: i64,
    pub as_u64: u64,
    pub as_ptr: PluginPtr,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__SysCallReg() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallReg>(),
        8usize,
        concat!("Size of: ", stringify!(_SysCallReg))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallReg>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallReg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReg>())).as_i64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReg),
            "::",
            stringify!(as_i64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReg>())).as_u64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReg),
            "::",
            stringify!(as_u64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReg>())).as_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReg),
            "::",
            stringify!(as_ptr)
        )
    );
}
pub type SysCallReg = _SysCallReg;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SysCallArgs {
    pub number: ::std::os::raw::c_long,
    pub args: [SysCallReg; 6usize],
}
#[test]
fn bindgen_test_layout__SysCallArgs() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallArgs>(),
        56usize,
        concat!("Size of: ", stringify!(_SysCallArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallArgs>())).number as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallArgs),
            "::",
            stringify!(number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallArgs>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallArgs),
            "::",
            stringify!(args)
        )
    );
}
pub type SysCallArgs = _SysCallArgs;
pub const SysCallReturnState_SYSCALL_DONE: SysCallReturnState = 0;
pub const SysCallReturnState_SYSCALL_BLOCK: SysCallReturnState = 1;
pub const SysCallReturnState_SYSCALL_NATIVE: SysCallReturnState = 2;
pub type SysCallReturnState = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysCallCondition {
    _unused: [u8; 0],
}
pub type SysCallCondition = _SysCallCondition;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SysCallReturn {
    pub state: SysCallReturnState,
    pub retval: SysCallReg,
    pub cond: *mut SysCallCondition,
}
#[test]
fn bindgen_test_layout__SysCallReturn() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallReturn>(),
        24usize,
        concat!("Size of: ", stringify!(_SysCallReturn))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallReturn>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallReturn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReturn>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReturn),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReturn>())).retval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReturn),
            "::",
            stringify!(retval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallReturn>())).cond as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallReturn),
            "::",
            stringify!(cond)
        )
    );
}
pub type SysCallReturn = _SysCallReturn;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Thread {
    _unused: [u8; 0],
}
pub type Thread = _Thread;
extern "C" {
    pub fn thread_ref(thread: *mut Thread);
}
extern "C" {
    pub fn thread_unref(thread: *mut Thread);
}
extern "C" {
    pub fn thread_run(
        thread: *mut Thread,
        argv: *mut *mut ::std::os::raw::c_char,
        envv: *mut *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn thread_resume(thread: *mut Thread);
}
extern "C" {
    pub fn thread_terminate(thread: *mut Thread);
}
extern "C" {
    pub fn thread_getReturnCode(thread: *mut Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_getReadablePtr(
        thread: *mut Thread,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn thread_getReadableString(
        thread: *mut Thread,
        plugin_src: PluginPtr,
        n: size_t,
        str_: *mut *const ::std::os::raw::c_char,
        strlen: *mut size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_getWriteablePtr(
        thread: *mut Thread,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn thread_getMutablePtr(
        thread: *mut Thread,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn thread_flushPtrs(thread: *mut Thread);
}
extern "C" {
    pub fn thread_nativeSyscall(
        thread: *mut Thread,
        n: ::std::os::raw::c_long,
        ...
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn thread_mallocPluginPtr(thread: *mut Thread, size: size_t) -> PluginPtr;
}
extern "C" {
    pub fn thread_freePluginPtr(thread: *mut Thread, ptr: PluginPtr, size: size_t);
}
extern "C" {
    pub fn thread_isRunning(thread: *mut Thread) -> bool;
}
extern "C" {
    pub fn thread_getProcessId(thread: *mut Thread) -> u32;
}
extern "C" {
    pub fn thread_getHostId(thread: *mut Thread) -> u32;
}
extern "C" {
    pub fn thread_getNativePid(thread: *mut Thread) -> pid_t;
}
extern "C" {
    pub fn thread_getNativeTid(thread: *mut Thread) -> pid_t;
}
extern "C" {
    pub fn thread_getID(thread: *mut Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_clone(
        thread: *mut Thread,
        flags: ::std::os::raw::c_ulong,
        child_stack: PluginPtr,
        ptid: PluginPtr,
        ctid: PluginPtr,
        newtls: ::std::os::raw::c_ulong,
        child: *mut *mut Thread,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn thread_setTidAddress(thread: *mut Thread, addr: PluginVirtualPtr);
}
extern "C" {
    pub fn thread_getTidAddress(thread: *mut Thread) -> PluginVirtualPtr;
}
extern "C" {
    pub fn thread_isLeader(thread: *mut Thread) -> bool;
}
pub type Packet = u8;
pub use self::_PacketDeliveryStatusFlags as PacketDeliveryStatusFlags;
pub const _PacketDeliveryStatusFlags_PDS_NONE: _PacketDeliveryStatusFlags = 0;
pub const _PacketDeliveryStatusFlags_PDS_SND_CREATED: _PacketDeliveryStatusFlags = 2;
pub const _PacketDeliveryStatusFlags_PDS_SND_TCP_ENQUEUE_THROTTLED: _PacketDeliveryStatusFlags = 4;
pub const _PacketDeliveryStatusFlags_PDS_SND_TCP_ENQUEUE_RETRANSMIT: _PacketDeliveryStatusFlags = 8;
pub const _PacketDeliveryStatusFlags_PDS_SND_TCP_DEQUEUE_RETRANSMIT: _PacketDeliveryStatusFlags =
    16;
pub const _PacketDeliveryStatusFlags_PDS_SND_TCP_RETRANSMITTED: _PacketDeliveryStatusFlags = 32;
pub const _PacketDeliveryStatusFlags_PDS_SND_SOCKET_BUFFERED: _PacketDeliveryStatusFlags = 64;
pub const _PacketDeliveryStatusFlags_PDS_SND_INTERFACE_SENT: _PacketDeliveryStatusFlags = 128;
pub const _PacketDeliveryStatusFlags_PDS_INET_SENT: _PacketDeliveryStatusFlags = 256;
pub const _PacketDeliveryStatusFlags_PDS_INET_DROPPED: _PacketDeliveryStatusFlags = 512;
pub const _PacketDeliveryStatusFlags_PDS_ROUTER_ENQUEUED: _PacketDeliveryStatusFlags = 1024;
pub const _PacketDeliveryStatusFlags_PDS_ROUTER_DEQUEUED: _PacketDeliveryStatusFlags = 2048;
pub const _PacketDeliveryStatusFlags_PDS_ROUTER_DROPPED: _PacketDeliveryStatusFlags = 4096;
pub const _PacketDeliveryStatusFlags_PDS_RCV_INTERFACE_RECEIVED: _PacketDeliveryStatusFlags = 8192;
pub const _PacketDeliveryStatusFlags_PDS_RCV_INTERFACE_DROPPED: _PacketDeliveryStatusFlags = 16384;
pub const _PacketDeliveryStatusFlags_PDS_RCV_SOCKET_PROCESSED: _PacketDeliveryStatusFlags = 32768;
pub const _PacketDeliveryStatusFlags_PDS_RCV_SOCKET_DROPPED: _PacketDeliveryStatusFlags = 65536;
pub const _PacketDeliveryStatusFlags_PDS_RCV_TCP_ENQUEUE_UNORDERED: _PacketDeliveryStatusFlags =
    131072;
pub const _PacketDeliveryStatusFlags_PDS_RCV_SOCKET_BUFFERED: _PacketDeliveryStatusFlags = 262144;
pub const _PacketDeliveryStatusFlags_PDS_RCV_SOCKET_DELIVERED: _PacketDeliveryStatusFlags = 524288;
pub const _PacketDeliveryStatusFlags_PDS_DESTROYED: _PacketDeliveryStatusFlags = 1048576;
pub type _PacketDeliveryStatusFlags = i32;
pub type PacketTCPHeader = _PacketTCPHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PacketTCPHeader {
    pub flags: ProtocolTCPFlags,
    pub sourceIP: in_addr_t,
    pub sourcePort: in_port_t,
    pub destinationIP: in_addr_t,
    pub destinationPort: in_port_t,
    pub sequence: guint,
    pub acknowledgment: guint,
    pub selectiveACKs: *mut GList,
    pub window: guint,
    pub timestampValue: SimulationTime,
    pub timestampEcho: SimulationTime,
}
#[test]
fn bindgen_test_layout__PacketTCPHeader() {
    assert_eq!(
        ::std::mem::size_of::<_PacketTCPHeader>(),
        64usize,
        concat!("Size of: ", stringify!(_PacketTCPHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_PacketTCPHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(_PacketTCPHeader))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).sourceIP as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(sourceIP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).sourcePort as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(sourcePort)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).destinationIP as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(destinationIP)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PacketTCPHeader>())).destinationPort as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(destinationPort)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).sequence as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(sequence)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).acknowledgment as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(acknowledgment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).selectiveACKs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(selectiveACKs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).window as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).timestampValue as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(timestampValue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PacketTCPHeader>())).timestampEcho as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_PacketTCPHeader),
            "::",
            stringify!(timestampEcho)
        )
    );
}
extern "C" {
    pub fn packet_new(
        payload: gconstpointer,
        payloadLength: gsize,
        hostID: guint,
        packetID: guint64,
    ) -> *mut Packet;
}
extern "C" {
    pub fn packet_copy(packet: *mut Packet) -> *mut Packet;
}
extern "C" {
    pub fn packet_ref(packet: *mut Packet);
}
extern "C" {
    pub fn packet_unref(packet: *mut Packet);
}
extern "C" {
    pub fn packet_setPriority(packet: *mut Packet, value: f64);
}
extern "C" {
    pub fn packet_setLocal(
        packet: *mut Packet,
        flags: ProtocolLocalFlags,
        sourceDescriptorHandle: gint,
        destinationDescriptorHandle: gint,
        port: in_port_t,
    );
}
extern "C" {
    pub fn packet_setUDP(
        packet: *mut Packet,
        flags: ProtocolUDPFlags,
        sourceIP: in_addr_t,
        sourcePort: in_port_t,
        destinationIP: in_addr_t,
        destinationPort: in_port_t,
    );
}
extern "C" {
    pub fn packet_setTCP(
        packet: *mut Packet,
        flags: ProtocolTCPFlags,
        sourceIP: in_addr_t,
        sourcePort: in_port_t,
        destinationIP: in_addr_t,
        destinationPort: in_port_t,
        sequence: guint,
    );
}
extern "C" {
    pub fn packet_updateTCP(
        packet: *mut Packet,
        acknowledgement: guint,
        selectiveACKs: *mut GList,
        window: guint,
        timestampValue: SimulationTime,
        timestampEcho: SimulationTime,
    );
}
extern "C" {
    pub fn packet_getPayloadLength(packet: *mut Packet) -> guint;
}
extern "C" {
    pub fn packet_getPriority(packet: *const Packet) -> gdouble;
}
extern "C" {
    pub fn packet_getHeaderSize(packet: *mut Packet) -> guint;
}
extern "C" {
    pub fn packet_getDestinationIP(packet: *mut Packet) -> in_addr_t;
}
extern "C" {
    pub fn packet_getDestinationPort(packet: *mut Packet) -> in_port_t;
}
extern "C" {
    pub fn packet_getSourceIP(packet: *mut Packet) -> in_addr_t;
}
extern "C" {
    pub fn packet_getSourcePort(packet: *mut Packet) -> in_port_t;
}
extern "C" {
    pub fn packet_getProtocol(packet: *mut Packet) -> ProtocolType;
}
extern "C" {
    pub fn packet_copyPayload(
        packet: *mut Packet,
        payloadOffset: gsize,
        buffer: gpointer,
        bufferLength: gsize,
    ) -> guint;
}
extern "C" {
    pub fn packet_copyTCPSelectiveACKs(packet: *mut Packet) -> *mut GList;
}
extern "C" {
    pub fn packet_getTCPHeader(packet: *mut Packet) -> *mut PacketTCPHeader;
}
extern "C" {
    pub fn packet_compareTCPSequence(
        packet1: *mut Packet,
        packet2: *mut Packet,
        user_data: gpointer,
    ) -> gint;
}
extern "C" {
    pub fn packet_addDeliveryStatus(packet: *mut Packet, status: PacketDeliveryStatusFlags);
}
extern "C" {
    pub fn packet_getDeliveryStatus(packet: *mut Packet) -> PacketDeliveryStatusFlags;
}
extern "C" {
    pub fn packet_toString(packet: *mut Packet) -> *mut gchar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Timer {
    _unused: [u8; 0],
}
pub type Timer = _Timer;
extern "C" {
    pub fn process_registerCompatDescriptor(
        proc_: *mut Process,
        compatDesc: *mut CompatDescriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn process_deregisterCompatDescriptor(proc_: *mut Process, handle: ::std::os::raw::c_int);
}
extern "C" {
    pub fn process_getRegisteredCompatDescriptor(
        proc_: *mut Process,
        handle: ::std::os::raw::c_int,
    ) -> *mut CompatDescriptor;
}
extern "C" {
    pub fn process_getReadablePtr(
        proc_: *mut Process,
        thread: *mut Thread,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_getWriteablePtr(
        proc_: *mut Process,
        thread: *mut Thread,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn process_getMutablePtr(
        proc_: *mut Process,
        thread: *mut Thread,
        plugin_src: PluginPtr,
        n: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn descriptor_unref(data: gpointer);
}
extern "C" {
    pub fn descriptor_setHandle(descriptor: *mut LegacyDescriptor, handle: gint);
}
pub use self::_CompatSocketTypes as CompatSocketTypes;
pub type CompatSocketObject = _CompatSocketObject;
pub type CompatSocket = _CompatSocket;
pub type Socket = [u64; 23usize];
pub const _CompatSocketTypes_CST_LEGACY_SOCKET: _CompatSocketTypes = 0;
pub const _CompatSocketTypes_CST_SOCKET_FILE: _CompatSocketTypes = 1;
pub type _CompatSocketTypes = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CompatSocketObject {
    pub as_legacy_socket: *mut Socket,
    pub as_socket_file: *const SocketFile,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__CompatSocketObject() {
    assert_eq!(
        ::std::mem::size_of::<_CompatSocketObject>(),
        8usize,
        concat!("Size of: ", stringify!(_CompatSocketObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_CompatSocketObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_CompatSocketObject))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CompatSocketObject>())).as_legacy_socket as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CompatSocketObject),
            "::",
            stringify!(as_legacy_socket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CompatSocketObject>())).as_socket_file as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CompatSocketObject),
            "::",
            stringify!(as_socket_file)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CompatSocket {
    pub type_: CompatSocketTypes,
    pub object: CompatSocketObject,
}
#[test]
fn bindgen_test_layout__CompatSocket() {
    assert_eq!(
        ::std::mem::size_of::<_CompatSocket>(),
        16usize,
        concat!("Size of: ", stringify!(_CompatSocket))
    );
    assert_eq!(
        ::std::mem::align_of::<_CompatSocket>(),
        8usize,
        concat!("Alignment of ", stringify!(_CompatSocket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CompatSocket>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CompatSocket),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CompatSocket>())).object as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CompatSocket),
            "::",
            stringify!(object)
        )
    );
}
extern "C" {
    pub fn compatsocket_fromSocketFile(socket: *const SocketFile) -> CompatSocket;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Futex {
    _unused: [u8; 0],
}
pub type Futex = _Futex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Address {
    _unused: [u8; 0],
}
#[doc = " An Address structure holds information used to identify nodes, allowing for"]
#[doc = " easy extraction of both integer and string forms of an IP address as well as"]
#[doc = " the string hostname associated with the IP. Address is an opaque structure and"]
#[doc = " should only be accessed using the functions in this class."]
pub type Address = _Address;
extern "C" {
    #[doc = " Retrieve the network-order integer version of this address"]
    #[doc = " @param address a valid, non-NULL Address structure previously created"]
    #[doc = " with address_new()"]
    #[doc = " @return the network-order IP"]
    pub fn address_toNetworkIP(address: *mut Address) -> guint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NetworkInterface {
    _unused: [u8; 0],
}
pub type NetworkInterface = _NetworkInterface;
extern "C" {
    pub fn networkinterface_wantsSend(
        interface: *mut NetworkInterface,
        socket: *const CompatSocket,
    );
}
extern "C" {
    pub fn host_getNewPacketID(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getID(host: *mut Host) -> GQuark;
}
extern "C" {
    pub fn host_getDefaultAddress(host: *mut Host) -> *mut Address;
}
extern "C" {
    pub fn host_getConfiguredRecvBufSize(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_getConfiguredSendBufSize(host: *mut Host) -> guint64;
}
extern "C" {
    pub fn host_lookupInterface(host: *mut Host, handle: in_addr_t) -> *mut NetworkInterface;
}
extern "C" {
    pub fn host_doesInterfaceExist(host: *mut Host, interfaceIP: in_addr_t) -> gboolean;
}
extern "C" {
    pub fn host_isInterfaceAvailable(
        host: *mut Host,
        type_: ProtocolType,
        interfaceIP: in_addr_t,
        port: in_port_t,
        peerIP: in_addr_t,
        peerPort: in_port_t,
    ) -> gboolean;
}
extern "C" {
    pub fn host_associateInterface(
        host: *mut Host,
        socket: *const CompatSocket,
        bindAddress: in_addr_t,
    );
}
extern "C" {
    pub fn host_disassociateInterface(host: *mut Host, socket: *const CompatSocket);
}
extern "C" {
    pub fn host_getRandomFreePort(
        host: *mut Host,
        type_: ProtocolType,
        interfaceIP: in_addr_t,
        peerIP: in_addr_t,
        peerPort: in_port_t,
    ) -> in_port_t;
}
extern "C" {
    pub fn worker_getActiveHost() -> *mut Host;
}
pub use self::_TriggerType as TriggerType;
pub const _TriggerType_TRIGGER_NONE: _TriggerType = 0;
pub const _TriggerType_TRIGGER_DESCRIPTOR: _TriggerType = 1;
pub const _TriggerType_TRIGGER_POSIX_FILE: _TriggerType = 2;
pub const _TriggerType_TRIGGER_FUTEX: _TriggerType = 3;
pub type _TriggerType = i32;
pub type TriggerObject = _TriggerObject;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TriggerObject {
    pub as_pointer: *mut ::std::os::raw::c_void,
    pub as_descriptor: *mut LegacyDescriptor,
    pub as_file: *const PosixFile,
    pub as_futex: *mut Futex,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__TriggerObject() {
    assert_eq!(
        ::std::mem::size_of::<_TriggerObject>(),
        8usize,
        concat!("Size of: ", stringify!(_TriggerObject))
    );
    assert_eq!(
        ::std::mem::align_of::<_TriggerObject>(),
        8usize,
        concat!("Alignment of ", stringify!(_TriggerObject))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_pointer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_pointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_descriptor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_descriptor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TriggerObject>())).as_futex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TriggerObject),
            "::",
            stringify!(as_futex)
        )
    );
}
pub type Trigger = _Trigger;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _Trigger {
    pub type_: TriggerType,
    pub object: TriggerObject,
    pub status: Status,
}
#[test]
fn bindgen_test_layout__Trigger() {
    assert_eq!(
        ::std::mem::size_of::<_Trigger>(),
        24usize,
        concat!("Size of: ", stringify!(_Trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<_Trigger>(),
        8usize,
        concat!("Alignment of ", stringify!(_Trigger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Trigger>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Trigger),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Trigger>())).object as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Trigger),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Trigger>())).status as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Trigger),
            "::",
            stringify!(status)
        )
    );
}
extern "C" {
    pub fn syscallcondition_new(trigger: Trigger, timeout: *mut Timer) -> *mut SysCallCondition;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Epoll {
    _unused: [u8; 0],
}
pub type Epoll = _Epoll;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SysCallHandler {
    pub host: *mut Host,
    pub process: *mut Process,
    pub thread: *mut Thread,
    pub timer: *mut Timer,
    pub epoll: *mut Epoll,
    pub blockedSyscallNR: ::std::os::raw::c_long,
    pub perfTimer: *mut GTimer,
    pub perfSecondsCurrent: gdouble,
    pub perfSecondsTotal: gdouble,
    pub numSyscalls: ::std::os::raw::c_long,
    pub referenceCount: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__SysCallHandler() {
    assert_eq!(
        ::std::mem::size_of::<_SysCallHandler>(),
        88usize,
        concat!("Size of: ", stringify!(_SysCallHandler))
    );
    assert_eq!(
        ::std::mem::align_of::<_SysCallHandler>(),
        8usize,
        concat!("Alignment of ", stringify!(_SysCallHandler))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).host as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(host)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).process as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(process)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).thread as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).timer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).epoll as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(epoll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SysCallHandler>())).blockedSyscallNR as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(blockedSyscallNR)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).perfTimer as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(perfTimer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SysCallHandler>())).perfSecondsCurrent as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(perfSecondsCurrent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SysCallHandler>())).perfSecondsTotal as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(perfSecondsTotal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).numSyscalls as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(numSyscalls)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SysCallHandler>())).referenceCount as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SysCallHandler),
            "::",
            stringify!(referenceCount)
        )
    );
}
extern "C" {
    pub fn syscallhandler_accept(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_accept4(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_bind(sys: *mut SysCallHandler, args: *const SysCallArgs)
        -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_connect(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getpeername(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getsockname(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getsockopt(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_listen(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_recvfrom(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_sendto(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_setsockopt(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_shutdown(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_socket(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_socketpair(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_close(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_dup(sys: *mut SysCallHandler, args: *const SysCallArgs) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getpid(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_getppid(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pipe(sys: *mut SysCallHandler, args: *const SysCallArgs)
        -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pipe2(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pread64(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_pwrite64(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_read(sys: *mut SysCallHandler, args: *const SysCallArgs)
        -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_set_tid_address(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_uname(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
extern "C" {
    pub fn syscallhandler_write(
        sys: *mut SysCallHandler,
        args: *const SysCallArgs,
    ) -> SysCallReturn;
}
